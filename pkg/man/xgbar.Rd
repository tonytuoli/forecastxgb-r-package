% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/xgbar.R
\name{xgbar}
\alias{xgbar}
\alias{xgbts}
\title{xgboost time series modelling}
\usage{
xgbar(y, xreg = NULL, maxlag = max(8, 2 * frequency(y)), nrounds = 100,
  nrounds_method = c("cv", "v", "manual"), nfold = ifelse(length(y) > 30,
  10, 5), lambda = 1, verbose = FALSE, seas_method = c("dummies",
  "decompose", "fourier", "none"), K = max(1, min(round(f/4 - 1), 10)),
  trend_method = c("none", "differencing"), weight = NULL, ...)
}
\arguments{
\item{y}{A univariate time series.}

\item{xreg}{Optionally, a vector or matrix of external regressors, which must have the same number of rows as y.}

\item{maxlag}{The maximum number of lags of \code{y} and \code{xreg} (if included) to be considered as features.}

\item{nrounds}{Maximum number of iterations \code{xgboost} will perform.  If \code{nrounds_method = 'cv'}, 
the value of \code{nrounds} passed to \code{xgboost} is chosen by cross-validation; if it is \code{'v'} 
then  the value of \code{nrounds} passed to \code{xgboost} is chosen by splitting the data into a training
set (first 80 per cent) and test set (20 per cent) and choosing the number of iterations with the best value.
If \code{nrounds_method = 'manual'} then \code{nrounds} iterations will be performed - unless you have chosen
it carefully this is likely to lead to overfitting and poor forecasts.}

\item{nrounds_method}{Method used to determine the value of nrounds actually given for \code{xgboost} for 
the final model.  Options are \code{"cv"} for row-wise cross-validation, \code{"v"} for validation on a testing
set of the most recent 20 per cent of data, \code{"manual"} in which case \code{nrounds} is passed through directly.}

\item{nfold}{Number of equal size subsamples during cross validation, used if \code{nrounds_method = 'cv'}.}

\item{lambda}{Value of lambda to be used for modulus power transformation of \code{y} (which is similar to Box-Cox transformation 
but works with negative values too), performed before using xgboost (and inverse transformed to the original scale afterwards).
Set \code{lambda = 1} if no transformation is desired.  
The transformation is only applied to \code{y}, not \code{xreg}.}

\item{verbose}{Passed on to \code{xgboost} and \code{xgb.cv}.}

\item{seas_method}{Method for dealing with seasonality.}

\item{K}{if \code{seas_method == 'fourier'}, the value of \code{K} passed through to \code{fourier} for order of Fourier series to be generated as seasonal regressor variables.}

\item{trend_method}{How should the \code{xgboost} try to deal with trends?  Currently the only options to \code{none} is 
\code{auto.arima}-style \code{differencing}, which is based on successive KPSS tests until there is no significant evidence the
remaining series is non-stationary.}

\item{weight, }{a vector indicating the weight for each row of the input.}

\item{...}{Additional arguments passed to \code{xgboost}.  Only works if nrounds_method is "cv" or "manual".}
}
\value{
An object of class \code{xgbar}.  These have a \code{forecast} method and are generally 
expected to be used in a way such as \code{forecast(my_xgbar_model, h = 24)}.  But the \code{xgbar}
object itself can be of use in model checking and diagnosis.  It is list with the following elements:
\describe{
\item{\code{y}}{The original value of \code{y} fed to \code{xgbar}}
\item{\code{y2}}{\code{y} except for its first \code{maxlag} values. }
\item{\code{x}}{The features used by \code{xgboost} to model \code{y2}.  \code{x} is basically 
a matrix of numbers created by the automated feature generation of \code{xgbar}, in particular 
the differencing (if asked for), seasonal adjustment (if asked for), and creation of lagged 
values.  If \code{y} is univariate,
\code{x} will be just the lagged values of \code{y} and will have \code{length(y) - maxlag} rows
and \code{maxlag} columns.  If \code{xreg} was supplied, \code{x} will have \code{maxlag * (ncol(xreg) + 1)}
columns - a set of columns for the lagged values of y, and a set of columns for each lagged value
of the xreg matrix.}
\item{\code{model}}{Object of class \code{xgb.Booster} returned by \code{xgboost}.  The actual 
xgboost model that regressed \code{y2} on \code{x}.}
\item{\code{fitted}}{Fitted values of \code{y}.  The first \code{maxlag} values will be \code{NA}.
The remainder are the predicted values of the xgboost regression of \code{y2} on \code{x}.}
\item{\code{maxlag}}{The original user-supplied value of \code{maxlag}, stored for future use by 
\code{forecast.xgbar}.}
\item{\code{seas_method}}{The original user-supplied value of \code{seas_method}, stored for future use by 
\code{forecast.xgbar}.}
\item{\code{diffs}}{The number of rounds of differencing applied to y to make it stationary, if 
\code{trend_method = "differencing"} was used.}
\item{\code{lambda}}{The original user-supplied value of \code{lambda} for modulus transformation, 
stored for future use by \code{forecast.xgbar}.}
\item{\code{method}}{A character string summarising the key arguments to xgbar, of the structure 
\code{xgbar(maxlag, diffs, seas_method)}.}
\item{\code{origxreg}}{The original user-supplied value of \code{origxreg}, 
stored for future use by \code{forecast.xgbar} (needed to create future values of lagged \code{xreg}
for the forecast period) .}
\item{code{ncolxreg}}{The number of columns in the original \code{xreg} matrix.}
\item{\code{decomp}}{If \code{seas_method = "decompose"} was used, this will be a list of the output 
from \code{decompose}, which decomposes y (called \code{x} by \code{decompose}) into seasonal, trend 
and random components.}
}
}
\description{
Fit a model to a time series using xgboost
}
\details{
This is the workhorse function for the \code{forecastxgb} package.
It fits a model to a time series.  Under the hood, it creates a matrix of explanatory variables 
based on lagged versions of the response time series, and (optionally) dummy variables (simple hot one encoding, or Fourier transforms) for seasons.  That 
matrix is then fed as the feature set for \code{xgboost} to do its stuff.
}
\examples{
# Univariate example - quarterly production of woolen yarn in Australia
woolmod <- xgbar(woolyrnq)
summary(woolmod)
plot(woolmod)
fc <- forecast(woolmod, h = 8)
plot(fc)

# Bivariate example - quarterly income and consumption in the US
if(require(fpp)){
consumption <- usconsumption[ ,1]
income <- matrix(usconsumption[ ,2], dimnames = list(NULL, "Income"))
consumption_model <- xgbar(y = consumption, xreg = income)
summary(consumption_model)
}
}
\references{
J. A. John and N. R. Draper (1980), "An Alternative Family of Transformations", \emph{Journal of the Royal Statistical
Society}.
}
\seealso{
\code{\link{summary.xgbar}}, \code{\link{plot.xgbar}}, \code{\link{forecast.xgbar}}, \code{\link{xgbar_importance}},
\code{\link[xgboost]{xgboost}}.
}
\author{
Peter Ellis
}
